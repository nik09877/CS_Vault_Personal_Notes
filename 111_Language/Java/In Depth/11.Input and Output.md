# Input/Output Streams
- An object from which we can read a sequence of bytes is called an input stream.
- An object to which we can write a sequence of bytes is called an output stream.
- The **abstract** classes `InputStream` and `OutputStream` form the basis for a hierarchy of I/O classes.
- As the `unicode` uses *multiple bytes* per character, a separate hierarchy provides classes for processing Unicode characters that inherit from the abstract `Reader` and `Writer` classes. These classes have read and write operations that are based on two-byte char values (that is, UTF-16 code units, as an integer between 0 and 65535) rather than byte values.

### Reading and Writing Bytes
- `System.in` is a predefined object of a subclass of `InputStream` that allows you to read information from standard input.
- In the `FileInputStream` class, `read` method reads one byte from a file.
- Both the `read` and `write` methods block until the byte is actually read or written. 
	- This means that if the `input stream` cannot immediately be accessed (usually because of a busy network connection), the **current thread blocks**. This gives other threads the chance to do useful work while the method is waiting for the input stream to become available again.
- When you have finished reading or writing to an input/output stream, close it by calling the `close` method.
	- This call frees up the operating system resources
	- Closing an output stream also flushes the buffer used for the output stream
	- You can also manually flush the output with the `flush` method.

#### API

![](Pasted_image_20230813141455.png)

### The Complete Stream Zoo

![](Pasted_image_20230813141653.png)

![](Pasted_image_20230813141710.png)

- `DataInputStream` and `DataOutputStream` let you read and write all the ***primitive Java types in binary format***.
- The `ZipInputStream` and `ZipOutputStream` let you read and write files in the familiar ***ZIP compression format***.
- There are four additional interfaces: `Closeable`, `Flushable`, `Readable`, and `Appendable`

![](Pasted_image_20230813142430.png)

#### API

![](Pasted_image_20230813142535.png)

### Combining Input/Output Stream Filters
- `FileInputStream` and `FileOutputStream` give you input and output streams attached to a disk file.
- You need to pass the file name or full path name of the file to the constructor.
```Java
FileInputStream fin = new FileInputStream("employee.dat"); 
//looks in the user directory for a file named employee.dat.
```
- To be able to read numbers from a file, first create a `FileInputStream` and then pass it to the constructor of a `DataInputStream`.
```Java
FileInputStream fin = new FileInputStream("employee.dat"); DataInputStream din = new DataInputStream(fin); 
double x = din.readDouble();
```
#### API

![](Pasted_image_20230813161545.png)

# Text Input and Output
- When you want to save data in text format they are stored as "strings"/
- The `InputStreamReader` class turns an input stream that contains **bytes** into a reader that emits Unicode code units.
- The `OutputStreamWriter` class turns an output stream of Unicode code units into a stream of bytes.
- Here is how you make an input reader that reads keystrokes from the console and converts them to Unicode :
```Java
Reader in = new InputStreamReader(System.in);
```
- You should always choose a specific encoding in the constructor for the `InputStreamReader`, for example :
```Java
Reader in = new InputStreamReader(new FileInputStream("data.txt"), StandardCharsets.UTF_8);
```

### How to Write Text Output
- For text output, use a `PrintWriter` class that has methods to print strings and numbers in text format.
```Java
PrintWriter out = new PrintWriter("employee.txt", "UTF-8");
// is equivalent to 
PrintWriter out = new PrintWriter( 
new FileOutputStream("employee.txt"), "UTF-8");
```
- To write to a print writer, use the same `print`, `println`, and `printf` methods that you used with `System.out`.
```Java
String name = "Harry Hacker"; 
double salary = 75000; 
out.print(name); 
out.print(' '); 
out.println(salary);
// This writes the characters Harry Hacker 75000.0 
//to the writer out.
```
- The characters are then converted to bytes and end up in the file employee.txt.
- If the writer is set to `autoflush` mode, all characters in the buffer are sent to their destination whenever `println` is called.
- You can enable or disable `autoflushing` by using the `PrintWriter(Writer writer, boolean autoFlush)` constructor.
#### API

![](Pasted_image_20230813163359.png)

### How to Read Text Input
- The easiest way to process arbitrary text is the Scanner class. You can construct a `Scanner` from any input stream.
- you can read a short text file into a string like this :
```Java
String content = new String(Files.readAllBytes(path),charset);
```
- But if you want the file as a sequence of lines, call :
```Java
List<String>lines = Files.readAllLines(path,charset);
```
- If the file is large, process the lines lazily :
```Java
try(Stream<String> lines = Files.lines(path,charset))
{
	. . .
}
```
- `BufferedReader` class has a `readLine` method that yields a line of text, or `null` when no more input is available.
```Java
InputStream inputStream = . . .; 
try (BufferedReader in = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))) 
{ 
	String line; 
	while ((line = in.readLine()) != null) 
	{ do something with line } 
}
```
- The `BufferedReader` class also has a `lines` method that yields a `Stream<String>`.
- A `BufferedReader` has no methods for reading numbers.

#### Example Code

![](Pasted_image_20230813165351.png)

### Character Encodings
- Characters are encoded into bytes.
- Java uses the Unicode standard for characters.
- Each character or “code point” has a 21-bit integer number.
- There are different character encodings—methods for packaging those 21-bit numbers into bytes.
- The most common encoding is UTF-8, which encodes each Unicode code point into a sequence of one to four bytes.
- Another common encoding is UTF-16, which encodes each Unicode code point into one or two 16-bit values. This is the encoding used in Java strings.

# Reading and Writing Binary Data
# Object Input/Output Streams and Serialization
# Working With Files
- The `Path interface` and `Files class` encapsulate the functionality required to work with the file system on the user’s machine.
### Paths
- A `Path` is a sequence of directory names, optionally followed by a file name.
- The first component of a path may be a root component such as `/` or `C:\`.
- A path that starts with a root component is **absolute**. Otherwise, it is **relative**.
- A path does not have to correspond to a file that actually exists. It is merely an abstract sequence of names.As you will see in the next section, when you want to create a file, you first make a path and then call a method to create the corresponding file.
##### Paths.get()
The static `Paths.get` method receives one or more strings, which it joins with the path separator of the default file system (`/` for a UNIX-like file system, `\` for Windows). It then parses the result, throwing an `InvalidPathException` if the result is not a valid path in the given file system.The result is a Path object.
```Java
Path absolute = Paths.get("/home", "harry"); 
Path relative = Paths.get("myprog", "conf", "user.properties");
```
##### resolve()
- It is very common to combine or resolve paths.
- The call `p.resolve(q)` returns a path according to these rules :
	- If q is absolute, then the result is q.
	- • Otherwise, the result is “p then q,” according to the rules of the file system.
```Java
//For example, suppose your application needs to find its working directory relative to a given base directory that is read from a configuration file, as in the preceding example.
Path workRelative = Paths.get("work"); 
Path workPath = basePath.resolve(workRelative);

//There is a shortcut for the resolve method that takes a string instead of a path:
Path workPath = basePath.resolve("work");
```

##### resolveSibling()
- It resolves against a path’s parent, yielding a sibling path.
```Java
//For example, if workPath is /opt/myapp/work, the call
Path tempPath = workPath.resolveSibling("temp");
//creates /opt/myXapp/temp.
```

##### relativize()
- It is the opposite of `resolve`.
- The call `p.relativize(r)` yields the path q which, when resolved with p, yields r.
- For example, relativizing `home/harry` against `/home/fred/input.txt` yields `../fred/input.txt`.

##### normalize()
- The `normalize` method removes any redundant `.` and `..` components.
- For example, normalizing the path` /home/harry/../fred/./input.txt` yields `/home/fred/input.txt`

##### toAbsolutePath()
- The `toAbsolutePath` method yields the absolute path of a given path, starting at a root component, such as `/home/fred/input.txt` or `c:\Users\fred\input.txt`.

#### Path Interface
The `Path` interface has many useful methods for taking `paths` apart.
```Java
Path p = Paths.get("/home", "fred", "myprog.properties"); 
Path parent = p.getParent(); // the path /home/fred 
Path file = p.getFileName(); // the path myprog.properties 
Path root = p.getRoot(); // the path /
```

#### API
![](Pasted_image_20230814144159.png)

### Reading and Writing Files
- The `Files` class makes quick work of common file operations.
- you can easily read the entire contents of a file :
```Java
byte[] bytes = Files.readAllBytes(path);
```
- If you want to read the file as a string :
```Java
byte[] bytes = Files.readAllBytes(path);
String content = new String(bytes, charset);
```
- if you want the file as a sequence of lines, call :
```Java
List<String> lines = Files.readAllLines(path, charset);
```

- if you want to write a string, call :
```Java
Files.write(path, content.getBytes(charset));
```
- To append to a given file, use :
```Java
Files.write(path, content.getBytes(charset), StandardOpenOption.APPEND);
```
- You can also write a collection of lines with :
```Java
Files.write(path, lines);
```

- If your files are large or binary, you can still use the familiar input/output streams or readers/writers :
```Java
InputStream in = Files.newInputStream(path); 
OutputStream out = Files.newOutputStream(path); 
Reader in = Files.newBufferedReader(path, charset); 
Writer out = Files.newBufferedWriter(path, charset);
```
- These convenience methods save you from dealing with `FileInputStream`, `FileOutputStream`, `BufferedReader`, or `BufferedWriter`.

#### API
![](Pasted_image_20230814144800.png)

### Creating Files and Directories

# Memory-Mapped Files
# Regular Expressions
