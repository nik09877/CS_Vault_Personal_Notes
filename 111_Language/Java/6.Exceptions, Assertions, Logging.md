# Dealing with Errors
- If an error happens, the program should
	- return to a safe state and enable the user to execute other commands
	- allow the user to save all the work and terminate the program gracefully

### The Classification of Exceptions

![](Pasted_image_20230812121456.png)

- In java an exception object is an instance of a class derived from `Throwable`.
- The `Error` hierarchy describes **internal errors** and **resource exhaustion** situations inside the Java runtime system. ***You should not throw an object of this type***.
- The `Exception` hierarchy also splits into two branches: exceptions that derive from `RuntimeException` and those that do not.
- A `RuntimeException` happens because you made a programming error.
- Any other exception occurs because a bad thing, such as an I/O error happened.
- Exceptions that inherit from `RuntimeException` include such problems as :
	- A bad Cast
	- An out-of-bounds array access
	- A null pointer access
- Exceptions that do not inherit from `RuntimeException` include :
	- Trying to read past the end of a file
	- Trying to open a file that doesn’t exist
	- Trying to find a `Class` object for a string that does not denote an existing class
- Any exception that derives from the class `Error` or the class `RuntimeException` is an *unchecked* exception, all other exceptions are called *checked* exceptions.
- The compiler checks that you provide exception handlers for all *checked* exceptions.

### Declaring Checked Exceptions
- A method must declare all the ***checked*** exceptions that it might throw separated by comma using `throws` keyword.
- If no handler catches the exception thrown by the method, the current thread of execution terminates.
- ***Unchecked*** exceptions are either beyond your control (`Error`) or result from conditions that you should not have allowed in the first place (`RuntimeException`), so you don't need to throw them.
- If your method fails to faithfully declare all ***checked*** exceptions, the compiler will issue an error message.
- An exception is thrown in any of the following four situations :
	- You call a method that throws a checked exception—for example, the `FileInputStream` constructor.
	- You detect an error and throw a ***checked*** exception with the `throw` statement
	- You make a programming error, that gives rise to an ***unchecked*** exception (`ArrayIndexOutOfBoundsException`)
	- An internal error occurs in the virtual machine or runtime library.
```Java
class MyAnimation
{
	public Image loadImage(String s)throws IOException, EOFException
	{
		. . .
	}
}
```
- If you override a method from a superclass, the ***checked*** exceptions that the subclass method declares cannot be more general than those of the superclass method.
- In particular, if the superclass method throws no checked exception at all, neither can the subclass.
- When a method in a class declares that it throws an exception that is an instance of a particular class, it may throw an exception of that class or of any of its subclasses.

### How to Throw an Exception
- Throwing an exception is easy if one of the existing exception classes works for you. In this case :
	- Find an appropriate exception class.
	- Make an object of that class.
	- Throw it.
```Java
String readData(Scanner in) throws EOFException
{
	. . .
	while(. . .)
	{
		if(!in.hasNext())
		{
			if(n<len)
				throw new EOFException();
			//The EOFException has a second constructor that takes a string argument.
		}
		. . .
	}
	return s;
}
```

### Creating Exception Classes
```Java
class FileFormatException extends IOException
{
	public FileFormatException() {}
	public FileFormatException(String gripe)
	{
		super(gripe);
	}
}

String readData(BufferedReader in) throws FileFormatException
{
	. . .
	while(. . .)
	{
		if(ch == -1)
		{
			if(n<len)
				throw new FIleFormatException();
		}
		. . .
	}
	return s;
}
```
- It is easy enough to create your own exception class. Just derive it from `Exception`, or from a child class of `Exception` such as `IOException`.
- It is customary to give both a **default constructor** and **a constructor that contains a detailed message**.
- The `toString` method of the `Throwable` superclass returns a string containing that detailed message, which is handy for debugging.
- `String getMessage()` : gets the detailed message of the `Throwable` object.

# Catching Exceptions
- If an exception occurs that is not caught anywhere, the program will terminate and print a message to the console, giving the **type of the exception** and a **stack trace**.
- To catch an exception, set up a `try/catch` block.
```Java
try
{
	. . .
}
catch(Exception e)
{
	//handler for this type
}
```
- If any code inside the try block throws an exception of the class specified in the catch clause, then :
	- The program skips the remainder of the code in the `try` block.
	- The program executes the handler code inside the `catch` clause.
- If none of the code inside the `try` block throws an exception, then the program skips the `catch` clause.
- If any of the code in a method throws an exception of a type other than the one named in the catch clause inside the body of the method, this method exits immediately.(Hopefully, one of its callers has already provided a catch clause for that type.)