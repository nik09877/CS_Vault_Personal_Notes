# Stream API
- Streams provide a view of data that lets you specify computations at a higher conceptual level than with collections.
- With streams, you provide what you want to do not how to do it.
### From Iterating to Stream Operations

For example count words in a list of strings having length greater than 12 :
```Java
long count = words.stream()
			.filter(w-> w.length() > 12)
			.count();
			 
```
- Simply changing `stream` into `parallelStream` allows the stream library to do the filtering and counting in parallel.
#### Stream vs Collection
1. A stream **does not store** its elements. 
	- They may be stored in an underlying collection or generated on demand.
2. Stream operations don’t mutate their source. 
	- For example, the `filter` method does not remove elements from a new stream, but it yields a new stream in which they are not present.
3. Stream operations are **lazy** when possible. 
	- This means they are not executed until their result is needed. 
	- For example, if you only ask for the first five long words instead of all, the `filter` method will stop filtering after the fifth match. As a consequence, you can even have infinite streams!
#### Working of a Stream
1. Create a stream.
2. Specify intermediate operations for transforming the initial stream into others, possibly in multiple steps.
3. Apply a terminal operation to produce a result. This operation forces the execution of the lazy operations that precede it. Afterwards, the stream can no longer be used.
#### API
![](Pasted_image_20230813190852.png)

### Stream Creation
- You can turn any collection into a stream with the `stream()` method of the `Collection` interface.
- If you have an array, use the static `Stream.of `method instead.
```Java
Stream<String> words = Stream.of(contents.split("\\PL+")); 
// split returns a String[] array

Stream<String> song = Stream.of("gently", "down", "the", "stream");
```
- Use` Arrays.stream(array, from, to)` to make a stream from array elements between positions `from` (inclusive) and `to` (exclusive).
```Java
Stream<String> silence = Stream.empty(); 
// Generic type <String> is inferred; same as Stream.<String>empty()
```

- The `Stream` interface has **two static methods** for making *infinite streams*.
- The `generate` method takes a function with no arguments (or, technically, an object of the `Supplier<T>` interface). Whenever a stream value is needed, that function is called to produce a value. 
```Java
//You can get a stream of constant values as :
Stream<String> echos = Stream.generate(() -> "Echo");

//or a stream of random numbers as
Stream<Double> randoms = Stream.generate(Math::random);
```
- To produce infinite sequences, use `iterate` method, which takes a seed value and a function (`UnaryOperator<T>`) and repeatedly applies the function to the previous result.
```Java
Stream<BigInteger> integers = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger.ONE));
```

#### API
![](Pasted_image_20230813192023.png)

### The filter, map, and flatMap Methods
#### filter
- The argument of filter is a` Predicate<T>`—that is, a function ***from T to boolean***.
```Java
List<String> wordList = . . .; 
Stream<String> longWords = wordList.stream()
				   .filter(w -> w.length() > 12);
```
#### map
- Often, you want to transform the values in a stream in some way. 
- Use the `map` method and pass the function that carries out the transformation.
```Java
Stream<String> lowercaseWords = words.stream().map(String::toLowerCase);

Stream<String> firstLetters = words.stream().map(s -> s.substring(0, 1));
```

#### flatMap
- Now, suppose you have a function that returns not just one value but a stream of values :
```Java
public static Stream<String> letters(String s) 
{ 
	List<String> result = new ArrayList<>(); 
	for (int i = 0; i < s.length(); i++) result.add(s.substring(i, i + 1)); return result.stream(); 
}

//using map
Stream<Stream<String>> result = words.stream().map(w -> letters(w));
// returns [. . .["y","o"], ["a","b","c"], . . .]

//using flatMap
Stream<String> flatResult = words.stream().flatMap(w -> letters(w)) // Calls letters on each word and flattens the results
```

### Extracting Substreams and Concatenating Streams
