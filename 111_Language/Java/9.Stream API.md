# Stream API
- Streams provide a view of data that lets you specify computations at a higher conceptual level than with collections.
- With streams, you provide what you want to do not how to do it.
### From Iterating to Stream Operations

For example count words in a list of strings having length greater than 12 :
```Java
long count = words.stream()
			.filter(w-> w.length() > 12)
			.count();
			 
```
- Simply changing `stream` into `parallelStream` allows the stream library to do the filtering and counting in parallel.
#### Stream vs Collection
1. A stream **does not store** its elements. 
	- They may be stored in an underlying collection or generated on demand.
2. Stream operations don’t mutate their source. 
	- For example, the `filter` method does not remove elements from a new stream, but it yields a new stream in which they are not present.
3. Stream operations are **lazy** when possible. 
	- This means they are not executed until their result is needed. 
	- For example, if you only ask for the first five long words instead of all, the `filter` method will stop filtering after the fifth match. As a consequence, you can even have infinite streams!
#### Working of a Stream
1. Create a stream.
2. Specify intermediate operations for transforming the initial stream into others, possibly in multiple steps.
3. Apply a terminal operation to produce a result. This operation forces the execution of the lazy operations that precede it. Afterwards, the stream can no longer be used.
#### API
![](Pasted_image_20230813190852.png)

### Stream Creation
- You can turn any collection into a stream with the `stream()` method of the `Collection` interface.
- If you have an array, use the static `Stream.of `method instead.
```Java
Stream<String> words = Stream.of(contents.split("\\PL+")); 
// split returns a String[] array

Stream<String> song = Stream.of("gently", "down", "the", "stream");
```
- Use` Arrays.stream(array, from, to)` to make a stream from array elements between positions `from` (inclusive) and `to` (exclusive).
```Java
Stream<String> silence = Stream.empty(); 
// Generic type <String> is inferred; same as Stream.<String>empty()
```

- The `Stream` interface has **two static methods** for making *infinite streams*.
- The `generate` method takes a function with no arguments (or, technically, an object of the `Supplier<T>` interface). Whenever a stream value is needed, that function is called to produce a value. 
```Java
//You can get a stream of constant values as :
Stream<String> echos = Stream.generate(() -> "Echo");

//or a stream of random numbers as
Stream<Double> randoms = Stream.generate(Math::random);
```
- To produce infinite sequences, use `iterate` method, which takes a seed value and a function (`UnaryOperator<T>`) and repeatedly applies the function to the previous result.
```Java
Stream<BigInteger> integers = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger.ONE));
```

#### API
![](Pasted_image_20230813192023.png)

### The filter, map, and flatMap Methods
#### filter
- The argument of filter is a` Predicate<T>`—that is, a function ***from T to boolean***.
```Java
List<String> wordList = . . .; 
Stream<String> longWords = wordList.stream()
				   .filter(w -> w.length() > 12);
```
#### map
- Often, you want to transform the values in a stream in some way. 
- Use the `map` method and pass the function that carries out the transformation.
```Java
Stream<String> lowercaseWords = words.stream().map(String::toLowerCase);

Stream<String> firstLetters = words.stream().map(s -> s.substring(0, 1));
```

#### flatMap
- Now, suppose you have a function that returns not just one value but a stream of values :
```Java
public static Stream<String> letters(String s) 
{ 
	List<String> result = new ArrayList<>(); 
	for (int i = 0; i < s.length(); i++) result.add(s.substring(i, i + 1)); return result.stream(); 
}

//using map
Stream<Stream<String>> result = words.stream().map(w -> letters(w));
// returns [. . .["y","o"], ["a","b","c"], . . .]

//using flatMap
Stream<String> flatResult = words.stream().flatMap(w -> letters(w)) // Calls letters on each word and flattens the results
```

### Extracting Substreams and Concatenating Streams
- The call` stream.limit(n)` returns a new stream that ends after `n` elements (or when the original stream ends, if it is shorter).
```Java
Stream<Double> randoms = Stream.generate(Math::random).limit(100);
```
- The call `stream.skip(n)`discards the first n elements.
- This is handy when splitting text into words since, due to the way the split method works, the first element is an unwanted empty string.
```Java
Stream<String> words = Stream.of(contents.split("\\PL+")).skip(1);
```
- You can concatenate two streams with the static `concat` method of the `Stream` class :
```Java
Stream<String> combined = Stream.concat( letters("Hello"), letters("World")); 
// Yields the stream ["H", "e", "l", "l", "o", "W", "o", "r", "l", "d"]
```
- Of course the first stream should not be infinite—otherwise the second one will never get a chance.

### Other Stream Transformations
- The `distinct` method returns a stream of unique elements.
```Java
Stream<String> uniqueWords = Stream.of("merrily", "merrily", "merrily", "gently").distinct(); 
// Only one "merrily" is retained
```
- For sorting a stream, there are several variations of the sorted method. One works for streams of `Comparable` elements, and another accepts a `Comparator`.
```Java
Stream<String> longestFirst = words.stream().sorted(Comparator.comparing(String::length).reversed());
```
- The `peek` method yields another stream with the same elements as the original, but a function is invoked every time an element is retrieved.
```Java
Object[] powers = Stream
.iterate(1.0, p -> p * 2) 
.peek(e -> System.out.println("Fetching " + e)) 
.limit(20)
.toArray();
```
#### API
![](Pasted_image_20230813201209.png)

### Simple Reductions
- Reductions are terminal operations. 
- They reduce the stream to a non-stream value that can be used in your program.
- `Optional<T> count()` : returns number of elements of a stream.
- `Optional<T> max()/min()`: returns max/min element of a stream.
- `Optional<T> findFirst()`: returns the first value in a nonempty collection, works well with `filter()`
- `Optional<T> findAny()`: yields any element of this stream, or an empty Optional if this stream is empty.
- `boolean anyMatch(Predicate<? super T> predicate)`
- `boolean allMatch(Predicate<? super T> predicate)`
- `boolean noneMatch(Predicate<? super T> predicate)` : returns true if any, all, or none of the elements of this stream match the given predicate.

### The Optional Type
- An `Optional<T>` object is a wrapper for either an object of type `T` or no object. 
- In the former case, we say that the value is present. 
- The `Optional<T>` type is intended as a safer alternative for a reference of type `T` that either refers to an object or is `null`.
#### How to work with it
- Use a method that either produces an *alternative* if the value is not present

```Java
// The wrapped string, or "" if none
String result = optionalString.orElse(""); 

// The function is only called when needed
String result = optionalString.orElseGet(() -> Locale.getDefault().getDisplayName());

// Supply a method that yields an exception object
String result = optionalString.orElseThrow(IllegalStateException::new); 
```
- Or use a method that *consumes* the value only if it is present.
- The `ifPresent` method accepts a function. If the optional value exists, it is passed to that function. Otherwise, nothing happens.
```Java
//optionalValue.ifPresent(v -> Process v);

optionalValue.ifPresent(results::add);
```
- When calling `ifPresent`, no value is returned from the function.
- If you want to process the function result, use `map` instead :
```Java
Optional<Boolean> added = optionalValue.map(results::add);
//Now added has one of three values: true or false wrapped into an Optional, if optionalValue was present, or an empty Optional otherwise.
```
- `optionalValue.get()` -> returns the value of the Optional, or throws a `NoSuchElementException` if empty.
- `optionalValue.isPresent()` -> returns true if optional value is not empty

#### Creating Optional Values
- If you want to write a method that creates an `Optional` object, there are several `static` methods for that purpose.
```Java
public static Optional<Double> inverse(Double x) 
{ 
	return x == 0 ? Optional.empty() : Optional.of(1 / x); 
}
```
- The `ofNullable` method is intended as a bridge from possibly null values to optional values.
- `Optional.ofNullable(obj)` returns `Optional.of(obj)` if obj is not null and `Optional.empty()` otherwise.

### Collecting Results
- You can call the `forEach` method to apply a function to each element, which is a terminating method.
- On a parallel stream, the `forEach` method traverses elements in **arbitrary** order. If you want to process them in stream order, call `forEachOrdered` instead.
- You can call `toArray` and get an array of the stream elements.
- The expression `stream.toArray()` returns an `Object[] array`. If you want an array of the correct type, pass in the array constructor `stream.toArray(String[]:new)`

#### Collector interface and Collectors class
- There is a convenient `collect` method that takes an instance of the `Collector` interface.
- The `Collectors` class provides a large number of factory methods for common collectors.

```Java
//collect stream into a list
List<String> result = stream.collect(Collectors.toList());

//into a set
Set<String> result = stream.collect(Collectors.toSet());

//into a collection
TreeSet<String> result = stream.collect(Collectors.toCollection(TreeSet::new));

//collect strings in a stream by concatenating them
String result = stream.collect(Collectors.joining(","));

//If your stream contains objects other than strings
String result = stream.map(String::toString).collect(Collectors.joining(","));

//reduce stream results to a sum,avg,max or min use one of summarizing(Int|Long|Double) methods.
IntSummaryStatistics summary = stream.collect( Collectors.summarizingInt(String::length)); 
double averageWordLength = summary.getAverage(); 
double maxWordLength = summary.getMax();
//These methods take a function that maps the stream objects to a number and yield a result of type (Int|Long|Double)SummaryStatistics, simultaneously computing the sum, count, average, minimum, and maximum
```

#### API
![](Pasted_image_20230813220846.png)

### Collecting into Maps

- Suppose you have a `Stream<Person>`  called `people` and want to collect the elements into a map so that later you can look up peoples names by their IDs.
```Java
Map<Integer,String> idToName = people.collect(
Collectors.toMap(Person::getId,Person::getName)
);
```
- When you want the value to be the same as the actual object :
```Java
Map<Integer,String> idToName = people.collect(
Collectors.toMap(Person::getId,Function.identity())
);
```
- If there is more than one element with the same key, there is a conflict, and the collector will throw an `IllegalStateException`. To avoid that :
```Java
//For each country find all languages in that country 
Map<String,Set<String>> countryLanguages = locales.collect(
Collectors.toMap(Locale::getCountry(),
				localeObj -> Collections.singleton(localeObj.getLang()),
				(oldVal,newVal) -> {
					//oldVal is a set, newVal is a String
					Set<String> union = new HashSet<>(oldVal);
					//union oldVal with newVal
					union.addAll(newVal);
					return union;
				})
);

//If you want a TreeMap
Map<String,Set<String>> countryLanguages = locales.collect(
Collectors.toMap(Locale::getCountry,
				localeObj -> Collections.singleton(localeObj.getLang()),//generate a singleton set for each map value
				(oldVal,newVal) -> {
					//oldVal,newVal are sets
					Set<String> union = new HashSet<>(oldVal);
					//union oldVal with newVal
					union.addAll(newVal);
					return union;
				},
				TreeMap::new)
);
```

- For each of the `toMap` methods, there is an equivalent `toConcurrentMap` method that yields a concurrent map. 
- A single concurrent map is used in the parallel collection process. When used with a parallel stream, a shared map is more efficient than merging maps. Note that elements are no longer collected in stream order, but that doesn’t usually make a difference.
### Grouping and Partitioning
- Above example using `groupingBy`:
```Java
Map<String,List<Locale>>countryToLocales = locales.collect(
Collectors.groupingBy(Locale::getCountry)
);
```
- When you need to partition your data into two sets use `partitioningBy`:
```Java
Map<Boolean,List<Locale>>englishAndOtherLocales = locales.collect(
Collectors
.partitioningBy(localeObj -> localeObj.getLanguage().equals("en"))
);
```

### Downstream Collectors
- The `groupingBy` method yields a map whose **values are lists**. If you want to process those lists in some way, supply a **downstream collector**.
