# Interfaces
- Interface is a way of describing what a class should do, without specifying how they should do it.
- A class can implement one or more interfaces.
- To make a class implement an interface, you carry out two steps:
		1. You declare that your class intends to implement the given interface using `implements` keyword.
		2. You supply definitions for all methods in the interface and declare them `public`.
- All methods in an interface are automatically public.
- However, when implementing the interface, you must declare the method as `public`. 
- Otherwise, the compiler assumes that the method has package access (default) for a class. The compiler then complains that you are trying to supply a more restrictive access privilege.

![[Pasted image 20230808173916.png]]

### Comparable Interface
-  For example, the `sort` method of `Arrays` class demands that the objects must implement the `Comparable` interface.
```Java
public interface Comparable<T>
{
	int compareTo(T other);
}
```
- The `compareTo` method returns negative number if the implicit parameter is smaller than the explicit parameter, zero if they are equal and a positive number otherwise.
```Java
class Employee implements Comparable<Employee>
{
	public int compareTo(Employee other)
	{
		return Double.compare(salary,other.salary); 
		// use Integer.compare(x,y) if x and y are integers
	}
}
```

### Properties of Interfaces
- You can never use the `new` operator to instantiate an interface
- However, you can still declare interface variables and it must refer to an object of a class that implements the interface.
- You can use `instanceof` to check whether an object implements an interface.
- Although you can't put instance fields in an interface, you can supply constants in them.
- ![[Pasted image 20230809111448.png]]
- Methods in an interface are `public` and fields are `public static final` by default.
- Methods can also be `private`, but as these can only be used in the interface, they act as helper methods.
-  You can supply a `default` implementation for any interface method. you must tag such a method with the `default` modifier.
```Java
public interface Comparable<T>
{
	default int compareTo(T other){ return 0; }
}
```
- A `default` method can call other methods.
```Java
public interface Collection
{
	int size(); // an abstract method
	default boolean isEmpty() { return size() == 0; }
}
```
#### Resolving Default Method Conflicts
What happens if the exact same method is defined as a `default` method in one `interface` and then again as a method of a `superclass` or another `interface`?
1. `Superclasses` win. If a `superclass` provides a `concrete method`, `default` methods with the same name and parameter types are simply ignored.
2. `Interfaces` clash. If an `interface` provides a `default` method, and another interface contains a method with the same name and parameter types (**default or not**), then you must resolve the conflict by overriding that method.
##### Example
```Java
interface person
{
	default String getName() { return "";}
}
interface Named
{
	default String getName() { 
		return getClass().getName();
	}
}
```
What happens if you form a class that implements both of them?
- The Class inherits two inconsistent `getName` methods and instead of choosing one over the other, the Java compiler reports an error and leaves it up to the programmer to resolve the ambiguity.
```Java
Class Student implements Person,Named
{
	public String getName() { 
		return Person.super.getName();
	}
}
```
- Even if the `getName()` method in `Named` class was not declared `default`, the `Student` class wouldn't have inherited the `default` method of `Person` interface. 
- The compiler would have reported an error if an implementation had not been provided for that method.
### Interfaces vs Abstract Classes
- The major difference is that interfaces support multiple inheritance.
- Abstract classes can have instance fields and concrete methods where as interfaces can't.

### Interfaces and Callbacks (Unfinished)
- In callback pattern you specify an action that should occur whenever a particular event occurs.

### The Comparator Interface

- There is a second version of the `Arrays.sort` method whose parameters are an `array` and a `comparator`—an instance of a class that implements the `Comparator` interface.
```Java
public interface Comparator<T>
{
	int compare(T first,T second);
}
```
#### Example
Suppose you want to sort an array of strings by increasing length.

```Java
public class LengthComparator implements Comparator<String>
{
	public int compare(String a,String b)
	{
		return a.length() - b.length();
	}
}

// To sort an array
String[] friends = {"peter", "paul", "Mary"};
Arrays.sort(friends,new LengthComparator());
```

### Object Cloning
![[Pasted image 20230809132907.png]]

```Java
var original = new Employee("John",50000);
Employee clonedEmp = original.clone(); //shallow copy
```
- The `clone` method is a protected method of `Object`, which means that your code cannot simply call it. 
- Only the Employee class can clone Employee objects.
- As you can see, the default cloning operation is “shallow”—it doesn’t clone objects that are referenced inside other objects.
- ![[Pasted image 20230809134902.png]]
- The `clone` method is declared `protected` in the `Object` class, so that your code can’t simply call `anObject.clone()`.
- But aren’t `protected` methods accessible from any subclass, and isn’t every class a subclass of `Object`?
- A subclass can call a `protected` `clone` method only to clone its own objects.
- You must redefine `clone` to be `public` to allow objects to be cloned by any method.
- And you must implement the `Clonable` interface, but it doesn't specify the `clone` method, it merely serves as a tag, indicating that cloning is supposed to happen in this class.
```Java
//shallow copy
class Employee implements Clonable
{

	public Employee clone() throws CloneNotSUpportedException
	{
		return (Employee) super.clone() ; 
		// call clone method of Object class and cast it.
	}
}
```

#### Deep Cloning
```Java
class Employee implements Clonable
{

	public Employee clone() throws CloneNotSUpportedException
	{
		// call clone method of Object class and cast it.
		Employee cloned = (Employee) super.clone() ;
		//clone mutable reference fields
		cloned hireDay = (Date) hireDay.clone();
		//Here the Date class must implement the Clonable interface
		return cloned; 
	}
}
```
# Lambda Expressions
- A lambda expression is a block of code that you can pass around so it can be executed later, once or multiple times.
Example :
```Java
//single statement
(String first, String second) -> first.length() - second.length()

//multiple statements
(String first, String second) -> { 
	if (first.length() < second.length()) return -1; 
	else if (first.length() > second.length()) return 1; 
	else return 0; 
}

//no parameter
() -> { for (int i = 100; i >= 0; i--) System.out.println(i); }

```

- If the parameter types of a lambda expression can be inferred, you can omit them.
Example :
```Java
Comparator<String> comp = (first, second) -> first.length() - second.length();


Arrays.sort(strArr, (first, second) - > first.length() - second.length());
```

- If a method has a single parameter with inferred type, you can even omit the parentheses
```Java
event -> System.out.println(event)
```

- It is illegal for a lambda expression to return a value in some branches but not in others.
```Java
(int x) -> { if (x >=0) return 1; } //ERROR
```


### Functional Interfaces
- The interface which has only one abstract method is called a functional interface.
- You can supply a lambda expression whenever an object of a class that implements an interface with a single abstract method is expected.
- You may wonder aren’t all methods in an interface abstract?
	- Actually, it has always been possible for an interface to redeclare methods from the `Object` class such as `toString` or `clone`, and these declarations do not make the methods abstract.
	- Interfaces can also declare non abstract `default` methods as well.
- Conversion to a functional interface is the only thing that you can do with a lambda expression in Java.

#### Functional Interface Examples

