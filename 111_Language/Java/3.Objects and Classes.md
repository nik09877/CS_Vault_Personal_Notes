# Introduction to Object-Oriented Programming
- OOP is a programming paradigm in which the the programs consists of classes and objects.
### Classes
- A class is a user defined data type which acts as a blueprint for making objects.
- All code that you write in Java is inside a class.
- **Encapsulation** is simply combining data and methods in one package and hiding the implementation details from the users of the object.
- The bits of data in an object are called its ***instance fields***, and the procedures that operate on the data are called its ***methods***.
- The key to making encapsulation work is to have methods *never directly access instance fields in a class other than their own.*
- Java, in fact, comes with a “cosmic superclass” called `Object`. All other classes extend this class.
- The concept of extending a class to obtain another class is called **inheritance**.
- When you extend an existing class, the new class has all the properties and methods of the class that you extend.
### Objects
- Objects are the instances of a class.
- It has three key characteristics:
	1. It's behaviour
	2. It's state
	3. It's Identity

### Identifying classes
- A simple rule of thumb in identifying classes is to look for **nouns** in the problem analysis.
- Methods, on the other hand, correspond to **verbs**.
### Relationship between classes
- The most common relationships between classes are:
	1. Dependence ("uses-a")
	2. Aggregation ("has-a")
	3. Inheritance ("is-a")
- The dependence, or “uses–a” relationship, is the most obvious and also the most general.
	- For example, the `Order` class uses the `Account` class because `Order` objects need to access `Account` objects to check for credit status. But the `Item` class does not depend on the `Account` class, because `Item` objects never need to worry about customer accounts.
	- Thus, a class depends on another class if its methods use or manipulate objects of that class.
	- Try to minimize the number of classes that depend on each other ("Coupling").
- The aggregation, or “has–a” relationship, is easy to understand because it is concrete.
	- For example, an `Order` object contains `Item` objects. Containment means that objects of class A contain objects of class B.
- The inheritance, or “is–a” relationship, expresses a relationship between a more special and a more general class.

- ![[Pasted image 20230804213025.png]]
- You draw classes as rectangles, and relationships as arrows with various adornments.
- ![[Pasted image 20230804213144.png]]

# Using Predefined Classes

### Objects and Object variables
- you use **constructors** to construct new instances.
- Constructors always have the same name as the class name.
- There is an important difference between objects and object variables. For example:
```Java
Date deadline; // deadline doesn't refer to any object
```
- It defines an object variable, deadline, that can refer to objects of type Date. It is important to realize that the variable deadline is not an object and, in fact, does not even refer to an object yet. You cannot use any Date methods on this variable at this time.
- An object variable doesn’t actually contain an object. It acts as a reference to an object.
- You can explicitly set an object variable to `null` to indicate that it currently refers to no object.
- If you apply a method to a `null` value, a `NullPointerException` occurs.

### LocalDate Class of Java Library
- When you use the `Date` class, the time is represented by the number of milliseconds (positive or negative) from a fixed point, the so-called epoch, which is 00:00:00 UTC, January 1, 1970. UTC is the Coordinated Universal Time, the scientific time standard which is, for practical purposes, the same as the more familiar GMT, or Greenwich Mean Time.
- ![[Pasted image 20230804214150.png]]
- ![[Pasted image 20230804214206.png]]
- ![[Pasted image 20230804214216.png]]
- ![[Pasted image 20230804214347.png]]

# Defining Your Own Classes
- To build a complete program, you combine several classes, one of which has a main method.
Program:
![[Pasted image 20230804214722.png]]
### Use of Multiple Source Files
- Many programmers prefer to each class into its own source file.
- When the Java compiler sees the `Employee` class being used inside `EmployeeTest.java`, it will look for a file named `Employee.class`. 
- If it does not find that file, it automatically searches for` Employee.java` and compiles it. 
- Moreover, if the timestamp of the version of `Employee.java` is newer than that of the existing `Employee.class` file, the Java compiler will automatically recompile the file.
### Constructors
- The constructor runs when you construct objects of the class.
- A constructor has the same name as the class.
- A class can have more than one constructor.
- A constructor can take zero, one, or more parameters.
- A constructor has no return value.
- A constructor is always called with the new operator.
- ![[Pasted image 20230804220622.png]]
### Implicit and Explicit Parameters
- ![[Pasted image 20230804221112.png]]
- The implicit parameter is the object that calls the method.
- Some people call the implicit parameter the target or receiver of the method call.
- In every method, the keyword `this` refers to the implicit parameter.
- The number inside the parentheses after the method name, is an explicit parameter.
Note:
![[Pasted image 20230804221259.png]]

### How to implement Encapsulation?
- you need to supply three items:
	- A private data field;
	- A public field accessor method;
	- A public field mutator method.
Note:
![[Pasted image 20230804221542.png]]

### Class-Based Access Privileges
- You know that a method can access the private data of the object on which it is invoked.
- But a method can access the private data of all objects of its class.
- For example, consider a method equals that compares two employees:
- ![[Pasted image 20230804221808.png]]

### Final Instance Fields
- `Final` field must be initialized when the object is constructed.
	- That is, you must guarantee that the field value has been set **after the end of every constructor**.
- The final modifier is particularly useful for fields whose type is **primitive** or an **immutable class**. (A class is immutable if none of its methods ever mutate its objects. For example, the String class is immutable.)
- For mutable classes, the final modifier can be confusing. For example, consider a field
- ![[Pasted image 20230804224021.png]]

# Static Fields and Methods
### Static Fields
- If you define a field as `static`, then there is only one such field per class.
### Static Constants
- Static variables are quite rare. However, static constants are more common.
- For example, the Math class defines a static constant:
- ![[Pasted image 20230804224259.png]]
### Static Methods
- Static methods are methods that do not operate on objects and belong to the class.
- Static methods don't have a `this` parameter.
- A static method can only access a static field not instance fields.
- To call a static method use `className.staticMethodName()`
- Use static methods in two situations:
	- When a method doesn’t need to access the object state because all needed parameters are supplied as explicit parameters (example: `Math.pow`).
	- When a method only needs to access static fields of the class.
- ![[Pasted image 20230804224655.png]]

### The Main Method
- Every class can have a main method. That is a handy trick for unit testing of classes.
- For example, you can add a main method to the Employee class:
- ![[Pasted image 20230804225001.png]]

# Method Parameters
- The Java programming language always uses **call by value**.
- There are, however, two kinds of method parameters: 
	- Primitive types (numbers, boolean values) 
	- Object references
- In case of object references, the method gets a copy of the object reference and both the original and the copy refer to the same object.
- A method cannot modify a parameter of a primitive type (that is, numbers or boolean values).
- A method can change the state of an object parameter.
- A method cannot make an object parameter refer to a new object.

### Note:
- Some programmers (and unfortunately even some book authors) claim that Java uses call by reference for objects. That is false. As this is such a common misunderstanding, it is worth examining a counterexample in detail.
- ![[Pasted image 20230804225451.png]]

# Object Construction
