# Classes, Super classes and Sub classes
### Defining Subclasses
- Use the Java keyword `extends` to denote inheritance.
- All inheritance in Java is public unlike C++.
- ![[Pasted image 20230805100318.png]]
- Subclasses have more functionality than their super classes.
- When designing classes, you place the most general methods in the superclass and more specialized methods in its subclasses.
### Overriding Methods
- When the child class implements a function having the same prototype as that of it's parent's, it is called function overriding .
- The call to the intended function is resolved at runtime, which is called **dynamic binding**.
- An object reference can refer to multiple actual types (parent/child class type), which is called **polymorphism**.
- ![[Pasted image 20230805102317.png]]
- When `e` refers to a `Manager` object, then the `getSalary` method of the Manager class is called.
- But `e` can't access the member variables and methods of `Manager` class as it is an object reference of `Employee` type. 
- `super` is a keyword that directs the compiler to invoke the super class method.
### Subclass Constructor
- In a subclass constructor the call using `super` must be the first statement.
- If the subclass constructor does not call a superclass constructor explicitly, the no-argument constructor of the superclass is invoked.
- If the superclass does not have a no-argument constructor and the subclass constructor does not call another superclass constructor explicitly, the Java compiler reports an error.

### Inheritance Hierarchies
- Java supports Single, multi-level, hierarchical and hybrid inheritance.
- It doesn't support multiple inheritance in classes.

### Polymorphism
- Same name but different functionalities.
- In the Java programming language, object variables are polymorphic.
- For example:
	- ![[Pasted image 20230806131535.png]]
	- A variable of type `Employee` can refer to an object of type `Employee` or to an object of any subclass of the `Employee` class (such as `Manager`, `Executive`, `Secretary`, and so on).
	- But it can only access those members that belongs to the `Employee` class.
- You cannot assign a superclass reference to a subclass variable.

### Understanding Method calls
- If the method is `private`, `static`, `final`, or a `constructor`, then the compiler knows exactly which method to call. This is called **static binding**.
- When you override a method, the subclass method must be at least as visible as the superclass method. 
	- In particular, if the superclass method is `public`, the subclass method must also be declared `public`.

### Preventing Inheritance
- `final` Classes can't be extended.
- No subclass can override a `final` method.
- All methods in a `final` class are automatically `final`, but not the instance fields.
- Use `instanceof` to check before casting from a superclass to a subclass.
	- ![[Pasted image 20230806132800.png]]
- Note:
- ![[Pasted image 20230806132852.png]]

### Abstract Classes
- A class with one or more abstract methods must itself be declared abstract.
- If you use the abstract keyword, you do not need to implement the method at all.
- In addition to abstract methods, abstract classes can have fields and concrete methods.
- ![[Pasted image 20230806133448.png]]
- When you extend an abstract class, you have two choices. 
	- You can leave some or all of the abstract methods undefined; then you must tag the subclass as abstract as well. 
	- Or you can define all methods, and the subclass is no longer abstract.
- A class can even be declared as abstract though it has no abstract methods.
- Abstract classes cannot be instantiated, but you can still create object variables of an abstract class and the compiler ensures that you invoke only methods that are declared in the abstract class using the object variable of the abstract class.

### Access Specifiers
- Here is a summary of the four access control modifiers in Java:
	1. Accessible in the class only (`private`)
	2. Accessible by the world (`public`)
	3. Accessible in the package and all subclasses (`protected`)
	4. Accessible in the package(`default`). No modifiers are needed.
# Object : The Cosmic Superclass
- Every class in Java extends the `Object` class.
- In Java, only the values of primitive types (numbers, characters, and boolean values) are not objects.
- All array types, no matter whether they are arrays of objects or arrays of primitive types, are class types that extend the `Object` class.
### Variable of Type Object
- You can use a variable of type `Object` to refer to objects of any type , to do anything specific with this value you need to apply **cast**.
```Java
Object obj = new Employee("Harry Hacker", 35000);
Employee e = (Employee) obj;
```

### The equals Method:
- It determines whether two object references are identical.
- ![[Pasted image 20230806155745.png]]
- The `getClass` method returns the class of an object.
- When you define the `equals` method for a subclass, first call equals on the superclass.
- ![[Pasted image 20230806155904.png]]
- `instanceof` returns true for all ancestors of a class.
- ![[Pasted image 20230806160412.png]]

### The hashCode Method
- A hash code is an integer that is derived from an object.
- If x and y are two distinct objects, there should be a high probability that `x.hashCode()` and `y.hashCode()` are different.
- The `hashCode` method is defined in the `Object` class. Therefore, every object has a default hash code.
- That hash code is derived from the object’s memory address.
- For strings, the hash codes are derived from their contents.
- If you redefine the `equals` method, you will also need to redefine the `hashCode` method for objects that users might insert into a hash table.
- The `hashCode` method should return an **integer** (which can be **negative**).
- Just combine the hash codes of the instance fields so that the hash codes for different objects are likely to be widely scattered.
- ![[Pasted image 20230806161300.png]]
- ![[Pasted image 20230806161200.png]]
- `Objects.hashCode` returns 0 if its argument is `null` and the result of calling `hashCode` on the argument otherwise. Also, use the static `Double.hashCode` method to avoid creating a `Double` object
- If `x.equals(y)` is `true`, then` x.hashCode()` must return the same value as `y.hashCode()`.

### The toString Method
- It returns a string representing the value of this object.
- It follows this format : the name of the class, then the field values enclosed in square brackets.
- ![[Pasted image 20230806174808.png]]
- Whenever an object is concatenated with a string by the “+” operator, the Java compiler automatically invokes the `toString` method to obtain a string representation of the object.
- ![[Pasted image 20230806175025.png]]


# Generic Array Lists
- `ArrayList` is a generic class with a type parameter.

### Declaring Array Lists
```Java
ArrayList<Employee> staff = new ArrayList<Employee>();
//or
var staff = new ArrayList<Employee>();
//or
ArrayList<Employee> staff = new ArrayList<>();

var elements = new ArrayList<>(); // returns ArrayList<Object>
```
- If you call add and the internal array is full, the array list automatically creates a bigger array and copies all the objects from the smaller to the bigger array.
- ![[Pasted image 20230806180249.png]]
- Methods:
- ![[Pasted image 20230806180503.png]]
- ![[Pasted image 20230806180545.png]]
- ![[Pasted image 20230806180611.png]]

# Object Wrappers and Autoboxing

- Sometimes you need to convert a primitive type like int to an object, that's when **wrapper classes** come in handy.
- The wrapper classes have obvious names: `Integer`, `Long`, `Float`, `Double`, `Short`, `Byte`, `Character`, and `Boolean`.
	- The first six inherit from the common superclass `Number`.
- The wrapper classes are immutable.
	- So you cannot change a wrapped value after the wrapper has been constructed. 
	- They are also **final**, so you cannot subclass them.
- ![[Pasted image 20230806181031.png]]
- ![[Pasted image 20230806181058.png]]
- The `==` operator, applied to wrapper objects, only tests whether the objects have identical memory locations, so call `equals` method when comparing wrapper objects.
- If you mix Integer and Double types in a conditional expression, then the Integer value is unboxed, promoted to double, and boxed into a Double:
- ![[Pasted image 20230806181404.png]]

# Methods with a variable number of parameters
- These are sometimes called `varargs` methods.
- ![[Pasted image 20230806184414.png]]
- Note:
- ![[Pasted image 20230806184426.png]]
- Here `printf` method is a `varargs` method.

# Enumeration Classes
- ![[Pasted image 20230806190037.png]]
- You can add constructors, methods, and fields to an enumerated type. 
- The constructors are only invoked when the enumerated constants are constructed.
- The constructor of an enumeration is always `private`.
- It is a syntax error to declare an enum constructor as `public` or `protected`
- ![[Pasted image 20230806190207.png]]
- You can omit the `private` modifier, in the above example.
- All enumerated types are subclasses of the class `Enum`.
- Methods:
- ![[Pasted image 20230806190554.png]]

# Reflection
- It is a library that provides excellent tools to write programs that manipulate java code dynamically.
- A program that can analyze the capabilities of classes is called **reflective**.
- You can use it to:
	- Analyze the capabilities of classes at runtime
	- Inspect objects at runtime—for example, to write a single `toString` method that works for all classes
	- Implement generic array manipulation code
	- Take advantage of `Method` objects that work just like function pointers in languages such as C++
- 
# Design Hints for Inheritance
1. Place common operations and fields in the superclass.
2. Don’t use protected fields.
3. Don’t use inheritance unless all inherited methods make sense.
4. Don’t change the expected behavior when you override a method.
5. Use polymorphism, not type information.
	1. ![[Pasted image 20230806185640.png]]
6. Don’t overuse reflection.
	1. The reflection mechanism lets you write programs with amazing generality, by detecting fields and methods at runtime.
	2. Reflection is fragile—with it, the compiler cannot help you find programming errors. Any errors are found at runtime and result in exceptions.